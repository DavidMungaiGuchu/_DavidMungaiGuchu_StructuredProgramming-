TASK 1 — POINTER THEORY 
1. Normal Variable vs Pointer
Normal Variable-Stores a value directly
Example: int x = 10;
x stores 10 Memory is accessed directly by the variable name
To change value, we assign a new value to x

Pointer-Stores the memory address of another variable
Example:
int x = 10;
int *p = &x;
p stores the address of x
To access or modify the value, we use dereferencing (*)

2. Variable vs Pointer Declaration and Definition
Variable Declaration & Definition
int a;
a = 5;
or
int a = 5;

Pointer Declaration & Definition
int *p;     
int a = 5;
p = &a;     
Meaning of Operators
& → Address of
* → Pointer / Dereference
Example:
int a = 10;
int *p = &a;

3. Dereferencing a Pointer
Dereferencing means accessing the value stored at the address.
Example:
int a = 10;
int *p = &a;

printf("%d", *p); // prints 10
Modify value using pointer:
*p = 20;    Now a becomes 20

4. When Are Pointers Preferred?
Use Cases
Swapping values in functions
Changing original variables from functions
Working with arrays
Dynamic memory allocation
Practical Examples
Swapping two numbers
Passing large data to functions efficiently

5. Limitations and Risks of Pointers
Can cause segmentation fault
Can point to invalid memory
Harder to debug
Wrong use can crash programs

6. Call by Value vs Call by Reference
Call by Value
Copy of value is sent
Original variable not changed
Call by Reference
Address is sent
Original variable can change

7. When to Use Each
Call by Value
When data should not change
Call by Reference
When you want to modify original data
Swapping values

Efficiency with large data
